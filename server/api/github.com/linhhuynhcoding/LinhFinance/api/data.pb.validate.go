// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: data.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Budgeting with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Budgeting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budgeting with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BudgetingMultiError, or nil
// if none found.
func (m *Budgeting) ValidateAll() error {
	return m.validate(true)
}

func (m *Budgeting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTitle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTitle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Title",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPurpose()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Purpose",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Purpose",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPurpose()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Purpose",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpendType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "SpendType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "SpendType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpendType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "SpendType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncomeType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "IncomeType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "IncomeType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncomeType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "IncomeType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Notes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetingValidationError{
					field:  "Notes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetingValidationError{
				field:  "Notes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if len(errors) > 0 {
		return BudgetingMultiError(errors)
	}

	return nil
}

// BudgetingMultiError is an error wrapping multiple validation errors returned
// by Budgeting.ValidateAll() if the designated constraints aren't met.
type BudgetingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BudgetingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BudgetingMultiError) AllErrors() []error { return m }

// BudgetingValidationError is the validation error returned by
// Budgeting.Validate if the designated constraints aren't met.
type BudgetingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BudgetingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BudgetingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BudgetingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BudgetingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BudgetingValidationError) ErrorName() string { return "BudgetingValidationError" }

// Error satisfies the builtin error interface
func (e BudgetingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudgeting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BudgetingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BudgetingValidationError{}

// Validate checks the field values on Pagination with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pagination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pagination with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PaginationMultiError, or
// nil if none found.
func (m *Pagination) ValidateAll() error {
	return m.validate(true)
}

func (m *Pagination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrentPage

	// no validation rules for PageSize

	// no validation rules for LastPage

	// no validation rules for Total

	// no validation rules for HasNextPage

	if len(errors) > 0 {
		return PaginationMultiError(errors)
	}

	return nil
}

// PaginationMultiError is an error wrapping multiple validation errors
// returned by Pagination.ValidateAll() if the designated constraints aren't met.
type PaginationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaginationMultiError) AllErrors() []error { return m }

// PaginationValidationError is the validation error returned by
// Pagination.Validate if the designated constraints aren't met.
type PaginationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaginationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaginationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaginationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaginationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaginationValidationError) ErrorName() string { return "PaginationValidationError" }

// Error satisfies the builtin error interface
func (e PaginationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaginationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaginationValidationError{}

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for Currency

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on SavingBucket with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SavingBucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SavingBucket with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SavingBucketMultiError, or
// nil if none found.
func (m *SavingBucket) ValidateAll() error {
	return m.validate(true)
}

func (m *SavingBucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "Desc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "Desc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "Desc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "TargetAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "TargetAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "TargetAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "CurrentAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "CurrentAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "CurrentAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "TargetDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "TargetDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "TargetDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInterestRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "InterestRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "InterestRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterestRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "InterestRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SavingBucketValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SavingBucketValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SavingBucketMultiError(errors)
	}

	return nil
}

// SavingBucketMultiError is an error wrapping multiple validation errors
// returned by SavingBucket.ValidateAll() if the designated constraints aren't met.
type SavingBucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SavingBucketMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SavingBucketMultiError) AllErrors() []error { return m }

// SavingBucketValidationError is the validation error returned by
// SavingBucket.Validate if the designated constraints aren't met.
type SavingBucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SavingBucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SavingBucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SavingBucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SavingBucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SavingBucketValidationError) ErrorName() string { return "SavingBucketValidationError" }

// Error satisfies the builtin error interface
func (e SavingBucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSavingBucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SavingBucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SavingBucketValidationError{}

// Validate checks the field values on Loan with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Loan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Loan with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LoanMultiError, or nil if none found.
func (m *Loan) ValidateAll() error {
	return m.validate(true)
}

func (m *Loan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetTittle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Tittle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Tittle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTittle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "Tittle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRepaid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Repaid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Repaid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepaid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "Repaid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLender()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Lender",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Lender",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLender()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "Lender",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPurposeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "PurposeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "PurposeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPurposeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "PurposeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBorrowDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "BorrowDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "BorrowDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBorrowDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "BorrowDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMarturityDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "MarturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "MarturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMarturityDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "MarturityDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Notes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoanValidationError{
					field:  "Notes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoanValidationError{
				field:  "Notes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if len(errors) > 0 {
		return LoanMultiError(errors)
	}

	return nil
}

// LoanMultiError is an error wrapping multiple validation errors returned by
// Loan.ValidateAll() if the designated constraints aren't met.
type LoanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanMultiError) AllErrors() []error { return m }

// LoanValidationError is the validation error returned by Loan.Validate if the
// designated constraints aren't met.
type LoanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanValidationError) ErrorName() string { return "LoanValidationError" }

// Error satisfies the builtin error interface
func (e LoanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanValidationError{}

// Validate checks the field values on DailyStats with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DailyStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DailyStats with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DailyStatsMultiError, or
// nil if none found.
func (m *DailyStats) ValidateAll() error {
	return m.validate(true)
}

func (m *DailyStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Spend

	// no validation rules for Income

	// no validation rules for Network

	// no validation rules for Date

	if len(errors) > 0 {
		return DailyStatsMultiError(errors)
	}

	return nil
}

// DailyStatsMultiError is an error wrapping multiple validation errors
// returned by DailyStats.ValidateAll() if the designated constraints aren't met.
type DailyStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DailyStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DailyStatsMultiError) AllErrors() []error { return m }

// DailyStatsValidationError is the validation error returned by
// DailyStats.Validate if the designated constraints aren't met.
type DailyStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DailyStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DailyStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DailyStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DailyStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DailyStatsValidationError) ErrorName() string { return "DailyStatsValidationError" }

// Error satisfies the builtin error interface
func (e DailyStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDailyStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DailyStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DailyStatsValidationError{}

// Validate checks the field values on Budgeting_Account with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Budgeting_Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budgeting_Account with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Budgeting_AccountMultiError, or nil if none found.
func (m *Budgeting_Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Budgeting_Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return Budgeting_AccountMultiError(errors)
	}

	return nil
}

// Budgeting_AccountMultiError is an error wrapping multiple validation errors
// returned by Budgeting_Account.ValidateAll() if the designated constraints
// aren't met.
type Budgeting_AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Budgeting_AccountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Budgeting_AccountMultiError) AllErrors() []error { return m }

// Budgeting_AccountValidationError is the validation error returned by
// Budgeting_Account.Validate if the designated constraints aren't met.
type Budgeting_AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Budgeting_AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Budgeting_AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Budgeting_AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Budgeting_AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Budgeting_AccountValidationError) ErrorName() string {
	return "Budgeting_AccountValidationError"
}

// Error satisfies the builtin error interface
func (e Budgeting_AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudgeting_Account.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Budgeting_AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Budgeting_AccountValidationError{}

// Validate checks the field values on Budgeting_Purpose with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Budgeting_Purpose) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budgeting_Purpose with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Budgeting_PurposeMultiError, or nil if none found.
func (m *Budgeting_Purpose) ValidateAll() error {
	return m.validate(true)
}

func (m *Budgeting_Purpose) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return Budgeting_PurposeMultiError(errors)
	}

	return nil
}

// Budgeting_PurposeMultiError is an error wrapping multiple validation errors
// returned by Budgeting_Purpose.ValidateAll() if the designated constraints
// aren't met.
type Budgeting_PurposeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Budgeting_PurposeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Budgeting_PurposeMultiError) AllErrors() []error { return m }

// Budgeting_PurposeValidationError is the validation error returned by
// Budgeting_Purpose.Validate if the designated constraints aren't met.
type Budgeting_PurposeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Budgeting_PurposeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Budgeting_PurposeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Budgeting_PurposeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Budgeting_PurposeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Budgeting_PurposeValidationError) ErrorName() string {
	return "Budgeting_PurposeValidationError"
}

// Error satisfies the builtin error interface
func (e Budgeting_PurposeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudgeting_Purpose.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Budgeting_PurposeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Budgeting_PurposeValidationError{}

// Validate checks the field values on Budgeting_SpendType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Budgeting_SpendType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budgeting_SpendType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Budgeting_SpendTypeMultiError, or nil if none found.
func (m *Budgeting_SpendType) ValidateAll() error {
	return m.validate(true)
}

func (m *Budgeting_SpendType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return Budgeting_SpendTypeMultiError(errors)
	}

	return nil
}

// Budgeting_SpendTypeMultiError is an error wrapping multiple validation
// errors returned by Budgeting_SpendType.ValidateAll() if the designated
// constraints aren't met.
type Budgeting_SpendTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Budgeting_SpendTypeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Budgeting_SpendTypeMultiError) AllErrors() []error { return m }

// Budgeting_SpendTypeValidationError is the validation error returned by
// Budgeting_SpendType.Validate if the designated constraints aren't met.
type Budgeting_SpendTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Budgeting_SpendTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Budgeting_SpendTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Budgeting_SpendTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Budgeting_SpendTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Budgeting_SpendTypeValidationError) ErrorName() string {
	return "Budgeting_SpendTypeValidationError"
}

// Error satisfies the builtin error interface
func (e Budgeting_SpendTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudgeting_SpendType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Budgeting_SpendTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Budgeting_SpendTypeValidationError{}

// Validate checks the field values on Budgeting_IncomeType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Budgeting_IncomeType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budgeting_IncomeType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Budgeting_IncomeTypeMultiError, or nil if none found.
func (m *Budgeting_IncomeType) ValidateAll() error {
	return m.validate(true)
}

func (m *Budgeting_IncomeType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return Budgeting_IncomeTypeMultiError(errors)
	}

	return nil
}

// Budgeting_IncomeTypeMultiError is an error wrapping multiple validation
// errors returned by Budgeting_IncomeType.ValidateAll() if the designated
// constraints aren't met.
type Budgeting_IncomeTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Budgeting_IncomeTypeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Budgeting_IncomeTypeMultiError) AllErrors() []error { return m }

// Budgeting_IncomeTypeValidationError is the validation error returned by
// Budgeting_IncomeType.Validate if the designated constraints aren't met.
type Budgeting_IncomeTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Budgeting_IncomeTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Budgeting_IncomeTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Budgeting_IncomeTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Budgeting_IncomeTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Budgeting_IncomeTypeValidationError) ErrorName() string {
	return "Budgeting_IncomeTypeValidationError"
}

// Error satisfies the builtin error interface
func (e Budgeting_IncomeTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudgeting_IncomeType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Budgeting_IncomeTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Budgeting_IncomeTypeValidationError{}
