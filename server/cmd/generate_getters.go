//go:build ignore

//go:generate go run generate_getters.go
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

var (
	SrcFilePattern = "%s%s.sql.go"
	OutFilePattern = "%s%s.gen.go"
	Extention      = "sql.go"

	DefaultSrcFiles = []string{"./internal/repository/models.go"}
)

// ⚠️ Đây là chương trình go:generate
// Nó sẽ parse file db.go và tạo file db_getters_gen.go tự động.
func main() {
	srcPath := "./internal/repository"

	srcFiles := make([]string, 0)
	srcFiles = append(srcFiles, DefaultSrcFiles...)

	// outFile := "./internal/repository/db_getters_gen.go"
	files, err := GetFilesWithExtension(srcPath, Extention)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	for _, file := range files {
		srcFiles = append(srcFiles, filepath.Join(srcPath, file))
	}

	fmt.Println(srcFiles)
	// return

	for _, srcFile := range srcFiles {
		outFile := strings.Replace(srcFile, ".go", ".gen.go", 1)

		fs := token.NewFileSet()
		node, err := parser.ParseFile(fs, srcFile, nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		var output strings.Builder
		output.WriteString("// Code generated by go:generate; DO NOT EDIT.\n")
		output.WriteString("package repository\n\n")

		funcs := make([]string, 0)
		cntPgType := 0

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok.String() != "type" {
				continue
			}

			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				typeName := ts.Name.Name
				for _, field := range st.Fields.List {
					if len(field.Names) == 0 {
						continue // bỏ qua embedded struct
					}
					fieldName := field.Names[0].Name
					methodName := "Get" + fieldName
					typee := getTypeString(field.Type)
					// fmt.Println(field.Type)
					funcs = append(funcs, fmt.Sprintf(
						"func (x %s) %s() %s { return x.%s }\n\n",
						typeName,
						methodName,
						typee,
						fieldName,
					))
					if strings.Contains(typee, "pgtype") {
						cntPgType++
					}
				}
			}
		}

		if cntPgType > 0 {
			output.WriteString("import \"github.com/jackc/pgx/v5/pgtype\"\n\n")
		}

		for _, f := range funcs {
			output.WriteString(f)
		}

		err = os.WriteFile(outFile, []byte(output.String()), 0644)
		if err != nil {
			panic(err)
		}
		fmt.Println("✅ Generated:", outFile)
	}

}

// getTypeString lấy tên type cơ bản của field
func getTypeString(expr ast.Expr) string {
	PrintStruct(expr)
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getTypeString(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeString(t.Elt)
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	default:
		return "interface{}"
	}
}

// GetFilesWithExtension returns all files in the folder (non-recursive) that match the extension.
func GetFilesWithExtension(folderPath, ext string) ([]string, error) {
	var matched []string

	entries, err := filepath.Glob(filepath.Join(folderPath, "*"+ext))
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		info, err := os.Stat(entry)
		if err != nil {
			continue
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ext) {
			matched = append(matched, info.Name())
		}
	}

	return matched, nil
}

func PrintStruct(v interface{}) {
	val := reflect.ValueOf(v)
	typ := reflect.TypeOf(v)

	if typ.Kind() == reflect.Ptr {
		val = val.Elem()
		typ = typ.Elem()
	}

	if typ.Kind() != reflect.Struct {
		fmt.Println("Not a struct")
		return
	}

	fmt.Println("Struct:", typ.Name())
	for i := 0; i < val.NumField(); i++ {
		field := typ.Field(i)
		value := val.Field(i)
		fmt.Printf("  %s %s = %v\n", field.Name, field.Type, value.Interface())
	}
}
